I will need you to make me multiple thing :

--> A smart contract named pixelBoard. That contract will be relatively simple. It will have a mapping that represent a board of 170*100 cells. There will be 4 of these board all recensed in a single nested array such as mapping(uint8 => mapping(uint256 => mapping(uint256 => cell)))
cell is a struct like this : cell {address owner, string color, uint256 edition}. (edition is the number of time the cell has been updated)
The mapping is accessed as : first entry = board (0, 1, 2, 3), second entry is X coord (0 to 169), third entry is Y coord (0 to 99). This will allow us to keep track of each board. Each board is 170*100 cells (so (170*100)*4 total cells = 68000)
Also, there should be another mapping to keep track of the number of pixel set by an address and the the number of pixel currently placed. This mapping looks like this :
mapping(address => pixelActivity)
where pixelActivity is a struct like this : pixelActivity {uint256 totalPixelPlaced, uint256 totalPixelAlive, uint256 totalEthPaid} where totalPixelPlaced will be incremented by one each time the sender place a pixel, and totalPixelAlive will be increased by one on the same occasion, and decreased when a pixel owned by the address is overwritten by another address (In the setPixel function, when setting the pixel in the mapping, look if pixel has been previously set, if it is the case, update both the previous owner mapping, the new setter mapping and then the board mapping.), for the totalEthPaid, it is incremented by the paid value in Eth for using the setPixel function (make sure that the value used is the cost value and not the sent amount as it can be > cost value and is either way sent back to the address.)
There will be one function accessible for everyone that is named setPixel(base64 encoded(uint8 boardId, uint256 x, uint256 y, string color)) the data for locating the pixel, board and setting the pixel color is like this so that the data to change a pixel can be pasted in one input field. There will be a modifier function used to restrict a function to only owner. There will be a function named retrieveEth restircted for only owner that will send all the balance of the contract to an address. Also add a function pause restricted by only owner that will allow to set a variable to false or true. if it is set to true, the setPixel function cannot be executed. Make the setPixel function payable. For a user to be able to set a pixel, he will have to pay some eth to the contract. The first time a pixel is set, it cost 0.000022 ETH. Then, it get's more expensive as the targeted cell has it's edition variable increase (15% more expensive each time so first 0.000022, then 0.000022*1.15, then 0.000022*1.15**2, then 0.000022*1.15**3 and so on.). Each time the setPixel function is successfully executed and a pixel is set, emit an event such as event(boardId, X, Y, color, address, edition, totalPixelPlaced, totalPixelAlive, totalEthPaid). Make sure that if a user pays more ETH than the needed amount for updating the selected pixel, the difference is sent back to him. Make sure that there is aa helper function getPixelCost that is callable by this contract and by a user that will get the chosen pixel edition variable and return it, along with the cost associated in ETH. There will also be a getPixelsCost function that do the same but with multiple cells value (precision are given later in the html section, make sure the way this function takes argument follow the pattern of the text copied from the html contract.)
Note that there are 16 colors possible : "black", "white", "gray", "silver", "maroon", "red", "purple", "fuscia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", and "aqua". Make sure that the setPixel function check is the color input given is one of these 16 colors (make a mapping(string color => bool) that the function will be able to call to verify color legality. this mapping shall be populated in the constructor of the contract.)
Make sure all the logic is implemented smoothly and that the errors or illegal execution are restricted. This contract will have to be veried on the block explorer.

--> Then, I will need to have a python bot using flask that will do the following things :
Listen for correctly shaped webhooks sent by an alchemy webhook that will listen for events from the pixelBoard contract and transmit them to the python bot.
Each time the bot will receive events data, It will first sort them by the board id. then, It will update a file that is shaped like an array of array, where each array[x][y] hold the cell data color and the edition number of the cell (the data is saved as a tuple in each cell, where first value is color and second is edition). There will be 4 of such files. It is important that these files have on each line 170 cell, and 100 lines. It would look like this :
[[cell0-0,cell1-0,cell2-0,cell3-0,...,cell169-0],
[cell0-1,cell1-1,cell2-1,cell3-1,...,cell169-1],
â€¦,
[cell0-99,cell1-99,cell2-99,cell3-99,...,cell169-99]]
note that there should not be any unnecessaries space in the file.
Initially, these four files will be empty with just the array structure. Then, they will be modified with the cell color gotten from the contract events through the webhook listener.
Also, we will have four more files that will keep up to date the data for each address. Each of these file represent a board Id, in which each address gotten through the event data will be kept track of for his activity on this board (number of pixels sets on this board, is incremented each time an event occur after an address has set a new pixel.) Structure of each of these file will be formatted as JSON :
{
"address1" : uint,
"address2" : uint,
...
}
Make sure that if an address is already figuring in a file, it's pointed value is incremented. Else, the address is added at the bottom and is first set to 1.
Each of these 8 files will be named board0, board1, board2, board3 and address0, address1, address2, address3.
The bot will update the related files every one minute with the data it has got since the last update.
Then it gets a bit complicated : There will be an html file, that will have inline css and js and no external links and dependencies. This file will serve as a base for the python script, where when needed, the python script copy the html data, modify it to add the corresponding board data in a board variable in the html, then push this updated html code to a base contract named OKComputerStore (0x04D7C8b512D5455e20df1E808f12caD1e3d766E5) where the function called has the following abi :
contract_abi = [
        {
            "inputs": [
                {"internalType": "uint256", "name": "tokenId", "type": "uint256"},
                {"internalType": "bytes32", "name": "key", "type": "bytes32"},
                {"internalType": "string", "name": "data", "type": "string"}
            ],
            "name": "storeString",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
        }
    ]
The key field has a fix data of "0xfc77a78c81db9794340a10dbcb0632f44d2d889f2cac2911b039a50f90ead7d0". the data field is where the utf-8 html code will be placed. As for the tokenId, there will be 4 of them that will be given later, but you must know that each of these tokenId must be matched with a boardId (helpId = {0 => tokenId0,1 => tokenId1,2 => tokenId2,3 => tokenId3}) tokenIds will be a natural number between 1 and 5000. Also, there will be 4 private keys in the .env file, each under a name like "pkey1532" or "pkey334" where the number represent the tokenId that would be used for the transaction using the private kay account as signer.
For submitting this transaction, make sure the gas price is forced to int(1e6). Also, handle support for multiple rpcs endoint declared in a .env file for the transactions to be retried on failure to send it. If all rpcs have failed, abandon the update for this wave and retry in one minute (eveytime a batch push fails because the transaction was not picked up by validator, add int(1e6) more for gas price at the next retry (max 5e6). Reset it to 1e6 on success. Make sure that this only applies to the board where the push was unsuccessful).
The python script push html updates for each board a maximum of once every 1 minutes, and only if the corresponding board has been updated from the pixelBoard solidity contract after the last push of the respective board html to the OKComputerStore contract. Following this logic and to minimize compute power of the bot, make sure that the boardX files are edited just before pushing the html data on the Base blockchain (data collected after last push of the board is used to modify the corresponding boardX file, then after that the boardX data is updated, it's data is added to the base html file and then the data is published. Make sure that webhook events occuring while this part of the logic is executed are correctly collected and no data gets lost.). For AddressX files, they are updated immediately upon receiving fresh data to avoid losing data if a pixel is modified multiples times before updating the relative page.
Note that when data is received, the color field which will be a string shall be converted to a number ("black":1, "white":0, "gray":2, "silver":3, "maroon":4, "red":5, "purple":6, "fushsia":7, "green":8, "lime":9, "olive":10, "yellow":11, "navy":12, "blue":13, "teal":14, and "aqua":15). This is neccessary to reduce the lenght of the data published to the OKComputerStore contract to limit the cost. Make sure that in the script of the html, the color data can be decoded.

--> Now adding precision about the base html file :
This file, as stated before, should only contain html, inline css and js.
The page will only display a title like "OK Computers's pixel board X" where X is the board id that the html file diplay so 0, 1, 2, or 3. this number is added by the python script when formatting the html to be sent to the OKComputerStore contract. The title will be centered at the top of the page and has a font size of 20px.
Then below this title and centered on the page, there will be a board that display the corresponding board using the data pasted by the python script in the variable. This data will be constructed using a loop that will read through every cell data. As inititally the cell will be empty, make sure that this is interpreted as a white cell. Each cell will be represented as multiple px depending of the dimension of the screen the board will is displayed on.
The cell dimension in px will be determinated using the smallest value between width and heigh / board X or Y dimension (If smallest value is width, divider used will be X, if it's height, it will be Y). Here are a few exemple :
Screen dimension 1920*1080, smallest value is height(Y), 0.9*1080 = 972 (as there is 10% of the screen height used for the title div), 972/Y = 972/100 = 9.7 , we round this to not have any decimals and always to the lowest, so we have 9. this mean that each cell will be 9*9 px on this device.
Screen dimension 1366*768, smallest value is height, 0.9*768 = 691.2, 691.2/100 = 6.912, each cell will be 6*6 px.
Screen dimension 428*926, smallest value is width, 0.95*428 = 406,6 (as 5% of the width will be used for spacing the display board from the screen border, so 2.5% of screen width on each side), 406,6/X = 406.6/170 = 2,3917..., each cell will be 2*2 px.
Note that screen ratio where X < Y are mobile devices.
When hovering a cell, it will be translated 10% bigger (overflow on top of adjacent cells) and glow a bit. Upon clicking on the cell, a little window will pop at the middle of the screen where the curent cell color will be displayed and it's coordinates.
Below this will be a little text saying the following : "You will need to pay some ETH to the contract for setting a pixel. this value can be seen for each specific cell by calling getPixelCost function in the read contract section. If you don't care, you can put a big eth value, the exceeding value will be sent back to you during the execution of the function.\nPixel cost increase the more a cell has been updated using the following formula :\n0.000022*1.15**editionNumber\n15% more costly each time\nUpon your setPixel transaction being successful, there is about 1-2 minutes of delay before this page gets updated.\nYou'll have to refresh this page to see the changes made.\nIf your pixel does not appear, it may be that the update is delayed due to transaction to the OK Computer contract failing, that your setPixel transaction failed or that someone overwrited your pixel in the meantime of this page being updated.".
Below this will be a copy button that copy all these values in the correct format they would have to be pasted in the basescan explorer in the setPixel function so that it would work success in it's execution. Next to this button, there will be a "Go to edit" button that upon clicking, redirect in a new page to https://basescan.org/address/FutureAddresOfPixelBoard#writeContract#F1 (F(number) represent the function order, so make it so that the first writable function in the contract is setPixel.)
Make sure that this pop up window can be closed by clicking out of it's scope. Also make sure this window is responsive relative to the screen dimensions (40% width, 30% height on a pc screen and 90% width, 50% height on a phone screen.). Make sure all the text in this window is centered and that text that woul overflow from it is in a line break mode so that the text continue in the next line.
Below the display board div, there will be a pixel constructor. this constructor as for two different cell coordinates (like 45,88 and 50, 68) and render a small display of the pixel board where each corner eaither top left or right and bottom left or right is delimited by the selected cells coord. with the values stated, cells from X=45 Y=88 to X=5 Y=68 will be rendered (45 to 50 is 6 cells, 88 to 68 is 20 cells, so here the number of cells to render are 6*20 so 180 cells where top left cell coordinates are 45,68 and bottom right coordinates are 50,88). This is rendered after the user have given 2 cells coordinates and clicked on the "Render Chunk" button. under this rendered chunk of board, add 16 buttons of every color handled by the contract (16). These buttons will be round and upon clicking them, it selects the color and by clicking a pixel on the chunk of the board, it changes the pixel displayed to the selected color. Then under this section will be 4 fields that the user can copy (each time there is a copy button next to the input) :
boardId : the id of the board where the user is
Xlist : the list of every X coord in the display, here it is 45, 46, ..., 50
Ylist : the list of every y coord in the display, here is is 68, 69, ...,88
colorList : the list of every color for each cell, formated in string value ie: "color", in this case there it would be 180 values
(Important note : As there are no functions in the pixelBoard contract that can handle setting multilples pixel at once, you will need to make one. Make sure that the function takes 4 arguments and is payable, each argument representing the above cells data lists or the boardId. Make sure this function check the cumulated estimated cost of modifying all the cells and to require the correct amount in eth for executing the function. Make sure it emit an event for every cell either in the same format as the one used in the classic setPixel function or in a different format that will be recognized by the python script so that every data are used and stored by the python script for the html pages to be up to date. Make sure that whichever model for emiting you choose, it must be handled by solidity and the python script. Also make sure this function send the exeeding eth for the setting of pixels to the sender.)
Make sure that these values are updated in real time as the user draw what he want to edit. Make sure each copy button copies the same values as the ones displayed.
Overall, no content should overflow from it's div. Make sure that the disposition of elements in the poping window is good and usable even on small display like a mobile phone.
For the Background of the page, it will be either a circular gradiant of green, blue, red or yellow depending of the board id, so this will be set accordingly in the js script when a user load the page, using the data pasted by the python script.
Make sure the html file does not have any external links or functions and the favicon is a base64 image computed with all the pixels color available in a cube form (4*4).
The code must be using relatively short variable and functions names to save space.
Note that the html size sent to the storage contract must absolutely be less than 65536 bytes. As the board data placed by the code should take at least 51201 bytes, you have 14000 bytes to make the rest of the html file, be it style, html or script. As such, make sure you optimize the code and have all the css and html that is raw coded in the file all inline with no spacing. For the javascript, minimize the spaces and display accordingly to fit in that limit, while keeping a readable form for humans if possible.

First, write me the html file and the solidity contract code and tell me how to publish and verify it. I'll ask you for the python code later. Use the latest solidity compiler version you know well.
